import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { mount, flushPromises } from '@vue/test-utils'
import DiscoveredDevicesMigrated from '../DiscoveredDevicesMigrated.vue'
import { useDiscoveredDevicesStore } from '@/stores/useDiscoveredDevicesStore'
import { useUnifiedStore } from '@/stores/UnifiedStore'
import type { UnifiedDevice } from '@/types/DeviceTypes'
import axios from 'axios'

// Mock axios
vi.mock('axios')

// Mock the component dependencies
vi.mock('@/stores/useDiscoveredDevicesStore', () => ({
  useDiscoveredDevicesStore: vi.fn()
}))

vi.mock('@/stores/UnifiedStore', () => ({
  useUnifiedStore: vi.fn()
}))

// Mock the ManualDeviceConfigMigrated component
vi.mock('../ManualDeviceConfigMigrated.vue', () => ({
  default: {
    name: 'ManualDeviceConfigMigrated',
    template: '<div data-testid="manual-device-config"></div>'
  }
}))

// Define the type for the component instance
interface ComponentInstance {
  discoveredAlpacaDevices: UnifiedDevice[]
  availableDevices: UnifiedDevice[]
  connectToDevice: (index: number) => Promise<void>
  isLoading: boolean
  refreshDiscoveredDevicesList: () => Promise<void>
  isDeviceAdded: (device: UnifiedDevice) => boolean
  selectedDeviceIndex: number | null
}

describe('DiscoveredDevicesMigrated.vue', () => {
  let mockDiscoveredDevicesStore: {
    isDiscovering: boolean
    lastDiscoveryTime: Date
    sortedDevices: Array<{
      address: string
      port: number
      AlpacaPort: number
      ServerName: string
      Manufacturer: string
      ManufacturerVersion: string
      Location: string
      isManualEntry: boolean
    }>
    discoverDevices: ReturnType<typeof vi.fn>
    getProxyUrl: ReturnType<typeof vi.fn>
  }

  let mockUnifiedStore: {
    devicesList: UnifiedDevice[]
    addDevice: ReturnType<typeof vi.fn>
    connectDevice: ReturnType<typeof vi.fn>
  }

  beforeEach(() => {
    // Reset mocks
    vi.clearAllMocks()

    // Setup the mock DiscoveredDevicesStore
    mockDiscoveredDevicesStore = {
      isDiscovering: false,
      lastDiscoveryTime: new Date(),
      sortedDevices: [
        {
          address: '192.168.1.100',
          port: 11111,
          AlpacaPort: 8000,
          ServerName: 'Test Server',
          Manufacturer: 'Test Manufacturer',
          ManufacturerVersion: '1.0',
          Location: 'Test Location',
          isManualEntry: false
        }
      ],
      discoverDevices: vi.fn(),
      getProxyUrl: vi.fn((server) => `/proxy/${server.address}/${server.port}`)
    }

    // Setup the mock for useDiscoveredDevicesStore
    vi.mocked(useDiscoveredDevicesStore).mockReturnValue(
      mockDiscoveredDevicesStore as unknown as ReturnType<typeof useDiscoveredDevicesStore>
    )

    // Setup mock axios responses
    vi.mocked(axios.get).mockImplementation((url: string) => {
      if (url.includes('/management/v1/description')) {
        return Promise.resolve({
          data: {
            Value: {
              ServerName: 'Test Server',
              Manufacturer: 'Test Manufacturer',
              ManufacturerVersion: '1.0',
              Location: 'Test Location'
            }
          }
        })
      } else if (url.includes('/management/v1/configureddevices')) {
        return Promise.resolve({
          data: {
            Value: [
              {
                DeviceType: 'Telescope',
                DeviceNumber: 0
              },
              {
                DeviceType: 'Camera',
                DeviceNumber: 0
              }
            ]
          }
        })
      }
      return Promise.resolve({ data: {} })
    })

    // Create a new instance of UnifiedStore for each test
    mockUnifiedStore = {
      devicesList: [],
      addDevice: vi.fn(),
      connectDevice: vi.fn().mockResolvedValue(undefined)
    }

    // Setup the mock for useUnifiedStore
    vi.mocked(useUnifiedStore).mockReturnValue(
      mockUnifiedStore as unknown as ReturnType<typeof useUnifiedStore>
    )
  })

  afterEach(() => {
    vi.resetAllMocks()
  })

  it('renders the component correctly', async () => {
    const wrapper = mount(DiscoveredDevicesMigrated)

    // Wait for any promises to resolve
    await flushPromises()

    expect(wrapper.find('h2').text()).toBe('Discovered Devices')
    expect(wrapper.find('.discover-btn').exists()).toBe(true)
  })

  it('calls discoverDevices on mount', async () => {
    mount(DiscoveredDevicesMigrated)

    // Wait for any promises to resolve
    await flushPromises()

    expect(mockDiscoveredDevicesStore.discoverDevices).toHaveBeenCalled()
  })

  it('refreshes device list when lastDiscoveryTime changes', async () => {
    // Mount component
    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // Clear the calls record
    vi.mocked(axios.get).mockClear()

    // Change the lastDiscoveryTime
    const newTime = new Date(mockDiscoveredDevicesStore.lastDiscoveryTime.getTime() + 5000)
    mockDiscoveredDevicesStore.lastDiscoveryTime = newTime

    // Force Vue to react to the change
    await wrapper.vm.$nextTick()
    await flushPromises()

    // Check that the API calls were made to fetch devices
    expect(axios.get).toHaveBeenCalledWith(
      '/proxy/192.168.1.100/11111/management/v1/configureddevices'
    )
  })

  it('adds devices to UnifiedStore when connectToDevice is called', async () => {
    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // Manually add a device to the component's data
    const vm = wrapper.vm as unknown as ComponentInstance
    vm.discoveredAlpacaDevices = [
      {
        id: 'test-device',
        name: 'Test Device',
        type: 'telescope',
        ipAddress: '192.168.1.100',
        port: 11111,
        isConnected: false,
        isConnecting: false,
        isDisconnecting: false,
        properties: {
          apiBaseUrl: '/proxy/192.168.1.100/11111/api/v1/telescope/0'
        }
      }
    ]

    // Force the component to update
    await wrapper.vm.$nextTick()

    // Now call connectToDevice with the index 0
    await vm.connectToDevice(0)

    // Verify that addDevice was called
    expect(mockUnifiedStore.addDevice).toHaveBeenCalled()
    // Verify that connectDevice was called with the correct ID
    expect(mockUnifiedStore.connectDevice).toHaveBeenCalled()
  })

  it('displays the correct number of devices', async () => {
    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // Manually add devices to the component's data
    const vm = wrapper.vm as unknown as ComponentInstance
    vm.discoveredAlpacaDevices = [
      {
        id: 'test-device-1',
        name: 'Test Telescope 0',
        type: 'telescope',
        ipAddress: '192.168.1.100',
        port: 11111,
        isConnected: false,
        isConnecting: false,
        isDisconnecting: false,
        properties: {
          apiBaseUrl: '/proxy/192.168.1.100/11111/api/v1/telescope/0',
          serverName: 'Test Server',
          manufacturer: 'Test Manufacturer'
        }
      },
      {
        id: 'test-device-2',
        name: 'Test Camera 0',
        type: 'camera',
        ipAddress: '192.168.1.100',
        port: 11111,
        isConnected: false,
        isConnecting: false,
        isDisconnecting: false,
        properties: {
          apiBaseUrl: '/proxy/192.168.1.100/11111/api/v1/camera/0',
          serverName: 'Test Server',
          manufacturer: 'Test Manufacturer'
        }
      }
    ]

    // Force the component to update
    await wrapper.vm.$nextTick()

    // Check if we get device cards rendered
    const deviceCards = wrapper.findAll('.device-card')
    expect(deviceCards.length).toBeGreaterThan(0)
  })

  it('includes the ManualDeviceConfigMigrated component', async () => {
    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    expect(wrapper.find('[data-testid="manual-device-config"]').exists()).toBe(true)
  })

  it('shows loading state during device connection', async () => {
    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // Manually add a device and set selectedDeviceIndex
    const vm = wrapper.vm as unknown as ComponentInstance
    vm.discoveredAlpacaDevices = [
      {
        id: 'test-device',
        name: 'Test Device',
        type: 'telescope',
        ipAddress: '192.168.1.100',
        port: 11111,
        isConnected: false,
        isConnecting: false,
        isDisconnecting: false,
        properties: {
          apiBaseUrl: '/proxy/192.168.1.100/11111/api/v1/telescope/0'
        }
      }
    ]

    // Set the loading state directly
    vm.selectedDeviceIndex = 0
    vm.isLoading = true

    // Force update
    await wrapper.vm.$nextTick()

    // Check for loading indicators
    expect(vm.isLoading).toBe(true)
  })

  // New tests
  it('handles API errors gracefully when fetching server details', async () => {
    // Mock a failed API call
    vi.mocked(axios.get).mockImplementationOnce((url: string) => {
      if (url.includes('/management/v1/description')) {
        return Promise.reject(new Error('API Error'))
      }
      return Promise.resolve({ data: {} })
    })

    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // The component should still render and not crash
    expect(wrapper.find('h2').text()).toBe('Discovered Devices')

    // Manually call refresh to test error handling
    const vm = wrapper.vm as unknown as ComponentInstance
    await vm.refreshDiscoveredDevicesList()

    // Component should recover from the error
    expect(vm.isLoading).toBe(false)
  })

  it('handles API errors gracefully when fetching configured devices', async () => {
    // Mock a failed API call
    vi.mocked(axios.get).mockImplementationOnce((url: string) => {
      if (url.includes('/management/v1/configureddevices')) {
        return Promise.reject(new Error('API Error'))
      }
      return Promise.resolve({ data: {} })
    })

    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // The component should still render and not crash
    expect(wrapper.find('h2').text()).toBe('Discovered Devices')

    // Manually call refresh to test error handling
    const vm = wrapper.vm as unknown as ComponentInstance
    await vm.refreshDiscoveredDevicesList()

    // Component should recover from the error
    expect(vm.isLoading).toBe(false)
  })

  it('handles connection errors gracefully', async () => {
    // Mock a failed connection
    mockUnifiedStore.connectDevice.mockRejectedValueOnce(new Error('Connection failed'))

    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // Manually trigger the connectToDevice method
    const vm = wrapper.vm as unknown as ComponentInstance
    await vm.connectToDevice(0)

    // Should handle the error and reset loading state
    expect(vm.isLoading).toBe(false)
  })

  it('filters out already added devices correctly', async () => {
    // Mock devices already in the store with matching API URLs
    mockUnifiedStore.devicesList = [
      {
        id: 'existing-device',
        name: 'Existing Device',
        type: 'telescope',
        ipAddress: '192.168.1.100',
        port: 11111,
        isConnected: true,
        isConnecting: false,
        isDisconnecting: false,
        properties: {
          apiBaseUrl: '/proxy/192.168.1.100/11111/api/v1/telescope/0'
        }
      }
    ]

    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // Manually populate discoveredAlpacaDevices
    const vm = wrapper.vm as unknown as ComponentInstance
    vm.discoveredAlpacaDevices = [
      {
        id: 'device1',
        name: 'Device 1',
        type: 'telescope',
        isConnecting: false,
        isDisconnecting: false,
        isConnected: false,
        properties: {}
      },
      {
        id: 'device2',
        name: 'Device 2',
        type: 'camera',
        isConnecting: false,
        isDisconnecting: false,
        isConnected: false,
        properties: {}
      }
    ]

    // Force computed property to re-evaluate
    await wrapper.vm.$nextTick()

    // Should only show the device that's not already added
    expect(vm.availableDevices.length).toBe(1)
    expect(vm.availableDevices[0].id).toBe('device2')
  })

  it('shows a message when all discovered devices are already added', async () => {
    // Mock devices already in the store
    mockUnifiedStore.devicesList = [
      {
        id: 'existing-device-1',
        name: 'Existing Device 1',
        type: 'telescope',
        ipAddress: '192.168.1.100',
        port: 11111,
        isConnected: true,
        isConnecting: false,
        isDisconnecting: false,
        properties: {
          apiBaseUrl: '/proxy/192.168.1.100/11111/api/v1/telescope/0'
        }
      },
      {
        id: 'existing-device-2',
        name: 'Existing Device 2',
        type: 'camera',
        ipAddress: '192.168.1.100',
        port: 11111,
        isConnected: true,
        isConnecting: false,
        isDisconnecting: false,
        properties: {
          apiBaseUrl: '/proxy/192.168.1.100/11111/api/v1/camera/0'
        }
      }
    ]

    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // Manually set discovered devices to match the already added ones
    const vm = wrapper.vm as unknown as ComponentInstance
    vm.discoveredAlpacaDevices = [
      {
        id: 'device1',
        name: 'Device 1',
        type: 'telescope',
        isConnecting: false,
        isDisconnecting: false,
        isConnected: false,
        properties: {}
      },
      {
        id: 'device2',
        name: 'Device 2',
        type: 'camera',
        isConnecting: false,
        isDisconnecting: false,
        isConnected: false,
        properties: {}
      }
    ]

    // Force computed property to re-evaluate
    await wrapper.vm.$nextTick()

    // Should show "all devices added" message
    expect(wrapper.find('.no-devices').exists()).toBe(true)
    expect(wrapper.find('.no-devices').text()).toContain('All discovered devices have been added')
  })

  it('displays the correct server and device information', async () => {
    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // Manually add a device to the component
    const vm = wrapper.vm as unknown as ComponentInstance
    vm.discoveredAlpacaDevices = [
      {
        id: 'test-device',
        name: 'Test Telescope 0',
        type: 'telescope',
        ipAddress: '192.168.1.100',
        port: 11111,
        isConnected: false,
        isConnecting: false,
        isDisconnecting: false,
        properties: {
          serverName: 'Test Server',
          manufacturer: 'Test Manufacturer'
        }
      }
    ]

    // Force update
    await wrapper.vm.$nextTick()

    // Check that device information is displayed correctly
    const deviceCard = wrapper.find('.device-card')

    expect(deviceCard.find('.device-name').text()).toBe('Test Telescope 0')
    expect(deviceCard.find('.device-type').text()).toBe('telescope')

    const detailRows = deviceCard.findAll('.detail-row')
    expect(detailRows[0].find('.detail-value').text()).toBe('Test Server')
    expect(detailRows[1].find('.detail-value').text()).toBe('192.168.1.100:11111')
    expect(detailRows[2].find('.detail-value').text()).toBe('Test Manufacturer')
  })

  it('disables scan button during discovery', async () => {
    // Set isDiscovering to true
    mockDiscoveredDevicesStore.isDiscovering = true

    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // Check that the scan button is disabled
    const scanButton = wrapper.find('.discover-btn')
    expect(scanButton.attributes('disabled')).toBeDefined()
    expect(scanButton.text()).toContain('Scanning...')
  })

  it('disables connect button when another device is being connected', async () => {
    const wrapper = mount(DiscoveredDevicesMigrated)
    await flushPromises()

    // Manually add devices
    const vm = wrapper.vm as unknown as ComponentInstance
    vm.discoveredAlpacaDevices = [
      {
        id: 'device1',
        name: 'Device 1',
        type: 'telescope',
        isConnecting: false,
        isDisconnecting: false,
        isConnected: false,
        properties: {}
      },
      {
        id: 'device2',
        name: 'Device 2',
        type: 'camera',
        isConnecting: false,
        isDisconnecting: false,
        isConnected: false,
        properties: {}
      }
    ]

    // Set selected device index to simulate a connection in progress
    vm.selectedDeviceIndex = 0

    // Force update
    await wrapper.vm.$nextTick()

    // Get all connect buttons
    const buttons = wrapper.findAll('.connect-btn')

    // Both buttons should be disabled when a connection is in progress
    expect(buttons[0].attributes('disabled')).toBeDefined()
    expect(buttons[1].attributes('disabled')).toBeDefined()

    // The button for the device being connected should show "Connecting..."
    expect(buttons[0].text()).toContain('Connecting...')
  })
})
